<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Tale of Performance - JavaScript, Rust, and WebAssembly | Widen Engineering</title>
  <meta name="description" content="Embark on a journey of optimization with me, learning in great detail about Rust, WebAssembly, and lots more along the way.  We will compare and contrast mul...">

  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/assets/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/assets/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/assets/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/assets/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/assets/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/assets/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/assets/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/favicon/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/assets/images/favicon/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">

<link rel="manifest" href="/assets/images/favicon/manifest.json"">

<meta name="msapplication-TileColor" content="#B72822">
<meta name="msapplication-TileImage" content="/assets/images/favicon/ms-icon-144x144.png" | relative_url }}">
<meta name="theme-color" content="#B72822">

  <link rel="stylesheet" href="/assets/css/app.css">
  <link rel="canonical" href="https://engineering.widen.com/blog/A-Tale-of-Performance-Javascript,-Rust,-and-WebAssembly/">
  <link rel="alternate" type="application/rss+xml" title="Widen Engineering" href="/feed.xml" />
</head>


  <body>

    <div class="full-width">
      <header class="site-header" role="banner">
  <div class="wrapper">
    <div class="logo">
      <a href="/">
        <img width="400" alt="Widen Engineering Logo" src="https://embed.widencdn.net/img/widen/c17yrvuaac/400px@2x/Widen Engineering White Logo.png?u=mcuc7i">
      </a>
    </div>
    
      <a class="subscribe" target="_blank" title="Email Subscription" href="https://feedburner.google.com/fb/a/mailverify?uri=WidenEngineering">Subscribe to Updates</a>
    
  </div>
</header>

    </div>

    <div class="wrapper">

      <main class="content" role="main">

        <div class="post">
    <header>
        <h1><a title="A Tale of Performance - JavaScript, Rust, and WebAssembly" href="/blog/A-Tale-of-Performance-Javascript,-Rust,-and-WebAssembly/">A Tale of Performance - JavaScript, Rust, and WebAssembly</a></h1>
        <time datetime="2019-01-14T00:00:00-06:00">Jan 14, 2019</time> • Tyler Wilcock
    </header>

    <article role="article">

      <p>Welcome to another Widen engineering blog post! Today, we’re going to embark on a journey of optimization. We’ll compare and contrast multiple approaches to solving a simple performance problem, one of which being the web’s newest and shiniest addition, <strong>WebAssembly</strong>.</p>

<p>Widen is a technology company, and like many other technology companies we do a lot of presentation (and, therefore, sorting) of data. Recently, I came across one of our internally-facing apps that has a table of data representing the status of certain inventory operations.  Users have the option to sort by a variety of fields in this table, such as the date and time the inventory operation ran, whether or not it was successful, the name of the account in question, and more.</p>

<p><a href="/images/tale-of-performance/inventory-table.png">
    <img src="/images/tale-of-performance/inventory-table.png" alt="Table showing the status of inventory operations." />
</a></p>

<p>This is a useful tool to have!  However, there is one problem - the sorting for this table is done client-side, and even when we limit it to retrieving only 1,000 results from the database, there is a noticeable (200-300ms) delay when sorting some of the more complex fields.  Is this acceptable for an internal tool?  Probably.  But I, like many of you, appreciate fast things, so let’s see how speedy we can make this thing go.</p>

<h2 id="the-starting-point">The starting point</h2>

<p>The current sorting algorithm is written in JavaScript and uses various JavaScript APIs and libraries, such as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare" target="_blank">String.localeCompare</a> and the <a href="https://momentjs.com/" target="_blank">moment.js</a> date library, to compare items when determining order.  Here’s what it looks like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">swapIfDesc</span> <span class="o">=</span> <span class="p">(</span><span class="nx">comparisonResult</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">sortDirection</span> <span class="o">===</span> <span class="nx">SortDirection</span><span class="p">.</span><span class="nx">DESC</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">comparisonResult</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="p">(</span><span class="nx">comparisonResult</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">comparisonResult</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">cmp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">)</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">)</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">sortInventoryRuns</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sortBy</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">inventoryRuns</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">rowA</span><span class="p">,</span> <span class="nx">rowB</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// These end up looking something like 'Widen (WIDEN)',</span>
    <span class="c1">// 'Customer 1 (CSTMR1)', etc.</span>
    <span class="kd">const</span> <span class="nx">accountNameA</span> <span class="o">=</span> <span class="p">...</span>
    <span class="kd">const</span> <span class="nx">accountNameB</span> <span class="o">=</span> <span class="p">...</span>

    <span class="k">switch</span> <span class="p">(</span><span class="nx">sortBy</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="na">accountProperName</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">...</span>
      <span class="p">}</span>

      <span class="k">case</span> <span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="na">ranOn</span><span class="p">:</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">...</span>
      <span class="p">}</span>

      <span class="k">case</span> <span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="na">wasSuccessful</span><span class="p">:</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">wasSuccessfulComparison</span> <span class="o">=</span> <span class="nx">cmp</span><span class="p">(</span><span class="nx">rowA</span><span class="p">[</span><span class="nx">sortBy</span><span class="p">],</span> <span class="nx">rowB</span><span class="p">[</span><span class="nx">sortBy</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">wasSuccessfulComparison</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">const</span> <span class="nx">isoA</span> <span class="o">=</span> <span class="nx">rowA</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">]</span> <span class="p">?</span>
            <span class="nx">moment</span><span class="p">(</span><span class="nx">rowA</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">]).</span><span class="nx">toISOString</span><span class="p">()</span> <span class="p">:</span>
            <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span>
          <span class="kd">const</span> <span class="nx">isoB</span> <span class="o">=</span> <span class="nx">rowB</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">]</span> <span class="p">?</span>
            <span class="nx">moment</span><span class="p">(</span><span class="nx">rowB</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">]).</span><span class="nx">toISOString</span><span class="p">()</span> <span class="p">:</span>
            <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span>

          <span class="kd">const</span> <span class="nx">ranOnComparison</span> <span class="o">=</span> <span class="nx">cmp</span><span class="p">(</span><span class="nx">isoA</span><span class="p">,</span> <span class="nx">isoB</span><span class="p">)</span>
          <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">ranOnComparison</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span>
            <span class="nx">accountNameA</span><span class="p">.</span><span class="nx">localeCompare</span><span class="p">(</span><span class="nx">accountNameB</span><span class="p">)</span> <span class="p">:</span>
            <span class="nx">ranOnComparison</span>
          <span class="k">return</span> <span class="nx">swapIfDesc</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">swapIfDesc</span><span class="p">(</span><span class="nx">wasSuccessfulComparison</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="p">...</span><span class="nx">other</span> <span class="k">case</span> <span class="nx">statements</span><span class="p">...</span>

      <span class="na">default</span><span class="p">:</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span>
          <span class="s2">`Unexpected default when sorting inventory runs: </span><span class="p">${</span><span class="nx">sortBy</span><span class="p">}</span><span class="s2">`</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re going to focus on the “was successful” sort in this post, as we could potentially be sorting by three different fields (operation success, the “ran on” date, and the account name) to get a consistent post-sort result.</p>

<p>We will begin with the most important step of performance tuning: a baseline.  Fortunately, all modern browsers have some form of a performance measurement tool. Here’s a snippet of Chrome’s in action against our code:</p>

<p><a href="/images/tale-of-performance/baseline-flamegraph.png">
    <img src="/images/tale-of-performance/baseline-flamegraph.png" align="middle" alt="Performance baseline - ~195ms" />
</a></p>

<p>However, for this experiment we want to test against multiple browsers (namely Chrome, Firefox, and Safari), so from here on out we will be looking at graphs.  Without further ado, here is the baseline performance of our initial JavaScript “was successful” sort in each browser:</p>

<p><a href="/images/tale-of-performance/benchmarks/baseline.png">
    <img src="/images/tale-of-performance/benchmarks/baseline.png" alt="Performance baseline graph - Chrome 183.93ms, Firefox 269.8ms, Safari 166.56ms" />
</a></p>

<p>Before we move on, there are some things I want to mention about this measurement, and all future measurements:</p>

<ol>
  <li>Unless otherwise noted, the code was built in release mode to ensure all possible optimizations were applied.</li>
  <li>The recorded time is the average of 25 repeated sort operations.</li>
  <li>The averages only include time spent in our <code class="language-plaintext highlighter-rouge">sortInventoryRuns</code> function.  So, for example, any work that React does post-sort to re-render our table is not included in these benchmarks.</li>
  <li>All measurements were taken with the app running locally on my <a href="https://support.apple.com/kb/sp704" target="_blank">2.8GHz-configured 2014 MacBook pro</a>.  I am using macOS Mojave v10.14.2.</li>
  <li>In Chrome and Safari, I used the built-in devtools to get exact runtimes for each sorting operation.  In Firefox, I used <a href="https://github.com/devtools-html/perf.html" target="_blank">this tool</a>.</li>
</ol>

<h2 id="keep-it-simple-stupid-kiss">Keep it simple, stupid (KISS)</h2>

<p>Reviewing our algorithm for sorting the “was successful” table field, we compare table rows in up to three different ways:</p>

<ol>
  <li>The success of the inventory operation</li>
  <li>The date and time the inventory operation ran</li>
  <li>The name of the account for which the inventory operation was performed</li>
</ol>

<p>The first comparison is very cheap; the only possible values are <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>.  The second operation is likely the most expensive, since we use <code class="language-plaintext highlighter-rouge">moment.js</code> to ensure our dates are in <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 format</a> before attempting to <a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank">lexicographically</a> compare them.  As described in <a href="https://stackoverflow.com/a/9576911" target="_blank">this StackOverflow post</a>, the ISO 8601 formats were designed with lexicographical comparison in mind.  What this means in practice is that we are able to use the built-in language comparison operators, such as <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>, to determine whether one date string is before or after another.  The third step in this algorithm requires use of <code class="language-plaintext highlighter-rouge">String.localeCompare</code>, which isn’t cheap but is likely far less expensive than the parsing and comparing of dates in step two.  A quick peek at Chrome’s flamegraph tool confirms this suspicion. The vast majority of our runtime is spent inside <code class="language-plaintext highlighter-rouge">moment</code> constructing our ISO 8601 date strings.</p>

<p>So, in true KISS mentality, let’s first reach for the most obvious solution, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank">the JavaScript Date API</a>.  There are a variety of ways to sort valid JavaScript <code class="language-plaintext highlighter-rouge">Date</code> objects, one of which being lexicographical comparison with <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code> and the like.  Also, since this API is a browser built-in, we know that it’s battle tested and written in heavily optimized C++ (or some similarly speedy language).  To illustrate this point, we can actually <a href="https://github.com/v8/v8/blob/41db90b0da7a0909272b3ac1ee229996ec3d5044/src/builtins/builtins-date.cc#L194" target="_blank">look at the code that powers Date objects in v8 (Chrome’s JavaScript engine)</a>.  Directly linked is the <code class="language-plaintext highlighter-rouge">Date</code> constructor built-in, and throughout the rest of that file, you’ll see built-ins for other familiar functions such as <code class="language-plaintext highlighter-rouge">BUILTIN(DateNow)</code> and <code class="language-plaintext highlighter-rouge">BUILTIN(DatePrototypeToString)</code>.</p>

<p>Rather than directly comparing <code class="language-plaintext highlighter-rouge">Date</code> objects, we’ll instead compare the result of each <code class="language-plaintext highlighter-rouge">Date</code>’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime" target="_blank">getTime() function</a>, since doing it that way <a href="https://jsperf.com/date-comparison-benchmarks2-twilco/1" target="_blank">seems be a bit faster</a>.  Here’s what our code looks like now:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sortInventoryRuns</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sortBy</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">inventoryRuns</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">rowA</span><span class="p">,</span> <span class="nx">rowB</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">accountNameA</span> <span class="o">=</span> <span class="p">...</span>
    <span class="kd">const</span> <span class="nx">accountNameB</span> <span class="o">=</span> <span class="p">...</span>

    <span class="k">switch</span> <span class="p">(</span><span class="nx">sortBy</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">other</span> <span class="k">case</span> <span class="nx">statements</span><span class="p">...</span>

      <span class="k">case</span> <span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="na">wasSuccessful</span><span class="p">:</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">wasSuccessfulComparison</span> <span class="o">=</span> <span class="nx">cmp</span><span class="p">(</span><span class="nx">rowA</span><span class="p">[</span><span class="nx">sortBy</span><span class="p">],</span> <span class="nx">rowB</span><span class="p">[</span><span class="nx">sortBy</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">wasSuccessfulComparison</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Out with the old...</span>
          <span class="c1">// const isoA = rowA[TABLE_FIELDS.ranOn] ?</span>
          <span class="c1">//   moment(rowA[TABLE_FIELDS.ranOn]).toISOString() :</span>
          <span class="c1">//   ' '</span>
          <span class="c1">// const isoB = rowB[TABLE_FIELDS.ranOn] ?</span>
          <span class="c1">//   moment(rowB[TABLE_FIELDS.ranOn]).toISOString() :</span>
          <span class="c1">//   ' '            </span>
          <span class="c1">// const ranOnComparison = cmp(isoA, isoB)</span>

          <span class="c1">// And in with the new!</span>
          <span class="kd">const</span> <span class="nx">ranOnComparison</span> <span class="o">=</span> <span class="nx">cmp</span><span class="p">(</span>
            <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">rowA</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">]).</span><span class="nx">getTime</span><span class="p">(),</span>
            <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">rowB</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">]).</span><span class="nx">getTime</span><span class="p">()</span>
          <span class="p">)</span>
          <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">ranOnComparison</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span>
            <span class="nx">accountNameA</span><span class="p">.</span><span class="nx">localeCompare</span><span class="p">(</span><span class="nx">accountNameB</span><span class="p">)</span> <span class="p">:</span>
            <span class="nx">ranOnComparison</span>
          <span class="k">return</span> <span class="nx">swapIfDesc</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">swapIfDesc</span><span class="p">(</span><span class="nx">wasSuccessfulComparison</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="p">...</span><span class="nx">other</span> <span class="k">case</span> <span class="nx">statements</span><span class="p">...</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Furthermore, as you may have noticed from the jsperf link in the previous paragraph, the date strings we get from the database (found in <code class="language-plaintext highlighter-rouge">rowA/B[TABLE_FIELDS.ranOn]</code>) are already in a valid form of the ISO 8601 format, which means they could be lexicographically compared without wrapping them in a <code class="language-plaintext highlighter-rouge">Date</code> at all!</p>

<p>Does this mean we should drop usage of <code class="language-plaintext highlighter-rouge">Date</code> completely, then?  It certainly seems like we could, but using <code class="language-plaintext highlighter-rouge">Date</code>s gives us a bit more flexibility in terms of date formats that we can use, as (by convention, <em>not</em> by standard) some browsers support <a href="http://tools.ietf.org/html/rfc2822#page-14">RFC 2822</a> and various other formats in addition to ISO 8601.  This makes it a more robust solution versus direct string comparison, so if it’s fast enough I think it would still be a good route for us to take.</p>

<p>Here are the benchmarks for our <code class="language-plaintext highlighter-rouge">Date</code> implementation:</p>

<p><a href="/images/tale-of-performance/benchmarks/date-get-time.png">
    <img src="/images/tale-of-performance/benchmarks/date-get-time.png" alt="Performance baseline graph - Chrome 183.93ms, Firefox 269.8ms, Safari 166.56ms" />
</a></p>

<p>Much better!  Versus the baseline implementation, our <code class="language-plaintext highlighter-rouge">Date</code> API implementation is <strong>96.6%</strong> faster in Chrome (<strong>183.93ms</strong> to <strong>6.14ms</strong>), <strong>97.6%</strong> faster in Firefox (<strong>269.8ms</strong> to <strong>6.4ms</strong>), and <strong>96.9%</strong> faster in Safari (<strong>166.56ms</strong> to <strong>5.13ms</strong>).</p>

<h2 id="so-were-done-right">So, we’re done, right?</h2>

<p>We certainly could be!  We have a fast, simple, and maintainable solution. What more could a developer want?  Well, while making this change, I got curious. How would WebAssembly perform in this scenario?  It’s unrealistic to think that it would perform better than a native API, but it would be an interesting experiment and could serve as a model for replacing performance-sensitive pieces of code that <em>aren’t</em> fixable with native APIs.</p>

<p>In the remainder of this blog post, we’ll set up a Rust (more on this choice later) stack that is capable of compiling to WebAssembly, replace our date comparison code with a Rust implementation, and then see how it stacks up to our two previous benchmarks.</p>

<h2 id="what-is-webassembly-anyway">What is WebAssembly anyway?</h2>

<p>For all those who haven’t yet been exposed to WebAssembly, <a href="https://webassembly.org/" target="_blank">here is what the WebAssembly team has described it as:</a></p>

<blockquote>
  <p>WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications.</p>
</blockquote>

<p>In addition to the binary format, there is also a textual WebAssembly format (<code class="language-plaintext highlighter-rouge">.wat</code>).  This allows WebAssembly to be read and edited by humans, since most of us aren’t very good at reading and writing in binary.  Here’s a <code class="language-plaintext highlighter-rouge">.wat</code> module that exports an <code class="language-plaintext highlighter-rouge">add</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(module
  (func $add (param $lhs i32) (param $rhs i32) (result i32)
    get_local $lhs
    get_local $rhs
    i32.add)
  (export "add" (func $add))
)
</code></pre></div></div>

<p>There are quite a few resources out there that go in to more detail about <code class="language-plaintext highlighter-rouge">.wat</code> (and WebAssembly in general), so if you’d like to learn more, check out the <a href="https://webassembly.org/" target="_blank">official WebAssembly webpage</a> or <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format" target="_blank">Mozilla’s .wat documentation</a>.</p>

<p>WebAssembly provides several performance advantages over JavaScript - for example, <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/" target="_blank">streaming compilation</a>.  And probably of equal importance, WebAssembly is here - version 1.0 has shipped and is available in Firefox, Chrome, Safari, and Edge.</p>

<p>Many popular languages can be compiled into WebAssembly, including C, C++, C#, and Rust.  In addition, many other languages are working on allowing compilation to WebAssembly, sometimes using external tools like <a href="https://github.com/kripken/emscripten" target="_blank">Emscripten</a>.</p>

<p>So, with all these choices, you might be wondering…</p>

<h2 id="why-rust">Why Rust?</h2>

<p>I chose Rust because performance is important for this use case, and as a systems programming language Rust is quite performant.  C and C++ offer similar levels of performance, but the key difference is that Rust guarantees thread and memory safety at <em>compile time</em>, whereas other languages either require you to keep track of memory yourself (which can be quite hard) or require costly runtime garbage collection.  Rust also has a nice package manager (<a href="https://github.com/rust-lang/cargo" target="_blank">cargo</a>), an expressive type system, and a spectacular community surrounding it.</p>

<p>Rust is vying to be one of the primary languages for writing WebAssembly-compilable code.  They have dedicated a <a href="https://github.com/rustwasm/team" target="_blank">working group</a> towards this goal, and have made <a href="https://github.com/rustwasm" target="_blank">some really powerful tools and documentation</a> to help facilitate WebAssembly development.  We will be making use of some of these tools later on in this post.</p>

<p>C#, another powerful language, has one major flaw when it’s used to compile to WebAssembly - the runtime.  In order to run any C# code as WebAssembly, you must also bring along the C# runtime compiled to WebAssembly, which (as of March 2018) <a href="https://github.com/aspnet/Blazor/issues/287#issuecomment-374152099" target="_blank">weighs in somewhere around 700kb</a>.  This is something the <a href="https://github.com/aspnet/Blazor/wiki/FAQ" target="_blank">Blazor team</a> is working hard to optimize, so if this piques your interest, do keep an eye out.</p>

<p>Rust does not have this problem. When compiling to WebAssembly, the only code we pay for is the code we end up writing.  This idea of <a href="https://blog.rust-lang.org/2015/05/11/traits.html" target="_blank">zero-cost abstractions</a> is a core tenet of Rust’s design, and the design of libraries fundamental to the ecosystem such as <a href="https://github.com/rustwasm/wasm-bindgen" target="_blank">wasm-bindgen</a> for WebAssembly or <a href="https://github.com/rust-embedded/embedded-hal" target="_blank">embedded-hal</a> for embedded systems development.</p>

<h2 id="setup">Setup</h2>

<p>Alright, now that we know a little bit more about both Rust and WebAssembly, let’s get our stack set up and get going.  Fortunately for us, the Rust WebAssembly team has already assembled a fantastic book detailing the basics of using Rust for compiling to WebAssembly.  We’ll be <a href="https://rustwasm.github.io/book/game-of-life/setup.html" target="_blank">following the setup instructions found there</a>.  In short, this is:</p>

<ol>
  <li>Installing the stable Rust toolchain</li>
  <li>Installing <a href="https://github.com/rustwasm/wasm-pack" target="_blank">wasm-pack</a>, which will build our Rust into WebAssembly and JavaScript “glue” code using other tools (such as <a href="https://github.com/rustwasm/wasm-bindgen" target="_blank">wasm-bindgen</a>) under the hood</li>
  <li>Installing <a href="https://github.com/ashleygwilliams/cargo-generate" target="_blank">cargo-generate</a> and using it to add the necessary components for Rust and WebAssembly into our existing project</li>
</ol>

<p>With all these installed, let’s switch to our frontend directory and <code class="language-plaintext highlighter-rouge">cargo generate</code> a <code class="language-plaintext highlighter-rouge">wasm-pack</code> template.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>frontend
<span class="c"># when prompted, we'll simply call our project 'rust'</span>
cargo generate <span class="nt">--git</span> https://github.com/rustwasm/wasm-pack-template
<span class="c"># remove various generated things we don't need since we have a pre-existing project</span>
<span class="nb">cd </span>rust <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> .git <span class="o">&amp;&amp;</span> <span class="nb">rm</span> .gitignore <span class="o">&amp;&amp;</span> <span class="nb">rm</span> .appveyor.yml <span class="o">&amp;&amp;</span> <span class="nb">rm</span> .travis.yml <span class="o">&amp;&amp;</span> <span class="nb">rm </span>README.md
</code></pre></div></div>

<p>In the end, this leaves us with a project structure looking like this:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inventory-project/
├── api/
├── app/
├── other pre-existing modules...
└── frontend/
    ├── other pre-existing directories...
    └── rust/
        ├── Cargo.toml
        └── src/
        |   ├── lib.rs
        |   └── utils.rs
        └── tests/
            └── web.rs
</code></pre></div></div>

<p>We’re in business!  Our soon-to-come Rustic WebAssembly functions will live in <code class="language-plaintext highlighter-rouge">src/lib.rs</code>, which currently looks something like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">crate</span> <span class="n">cfg_if</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">crate</span> <span class="n">wasm_bindgen</span><span class="p">;</span>

<span class="k">mod</span> <span class="n">utils</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">cfg_if</span><span class="p">::</span><span class="n">cfg_if</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">wasm_bindgen</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="nd">cfg_if!</span> <span class="p">{</span>
    <span class="c">// When the `wee_alloc` feature is enabled, use `wee_alloc`</span>
    <span class="c">// as the global allocator.</span>
    <span class="k">if</span> <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"wee_alloc"</span><span class="nd">)]</span> <span class="p">{</span>
        <span class="k">extern</span> <span class="n">crate</span> <span class="n">wee_alloc</span><span class="p">;</span>
        <span class="nd">#[global_allocator]</span>
        <span class="k">static</span> <span class="n">ALLOC</span><span class="p">:</span> <span class="nn">wee_alloc</span><span class="p">::</span><span class="n">WeeAlloc</span> <span class="o">=</span> <span class="nn">wee_alloc</span><span class="p">::</span><span class="nn">WeeAlloc</span><span class="p">::</span><span class="n">INIT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[wasm_bindgen]</span>
<span class="k">extern</span> <span class="p">{</span>
    <span class="c">// Import the `window.alert` function from the Web.</span>
    <span class="k">fn</span> <span class="nf">alert</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">#[wasm_bindgen]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// Export a `greet` function from Rust to JavaScript that</span>
    <span class="c">// alerts a pleasant greeting.</span>
    <span class="nf">alert</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"Hello from WebAssembly, {}!"</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s briefly touch on what’s going on here.  Starting from the top, the first interesting thing you might notice is this <code class="language-plaintext highlighter-rouge">wee_alloc</code> business.  <code class="language-plaintext highlighter-rouge">wee_alloc</code> is a memory allocator that is optimized to be as small as possible, which is important on the web because each extra kilobyte directly impacts page load speed.  <a href="https://github.com/rustwasm/wee_alloc#wee_alloc" target="_blank">The README for wee_alloc</a> goes into much greater detail on this subject, so check it out for an interesting read.</p>

<p>The next thing of note are the <code class="language-plaintext highlighter-rouge">#[wasm_bindgen]</code> annotations, which are provided by the <a href="https://github.com/rustwasm/wasm-bindgen" target="_blank">wasm-bindgen crate</a>.  Per <a href="https://github.com/rustwasm/wasm-bindgen#wasm-bindgen" target="_blank">wasm-bindgen’s own README</a>, it facilitates high-level interactions between WebAssembly modules and JavaScript.  Put even more simply, it allows you to “import JavaScript things into Rust and export Rust things to JavaScript.”  In our <code class="language-plaintext highlighter-rouge">src/lib.rs</code> example above, we could <code class="language-plaintext highlighter-rouge">import</code> and call the <code class="language-plaintext highlighter-rouge">greet</code> function exactly like we do other JavaScript modules and functions.  This is pretty sweet!</p>

<p><code class="language-plaintext highlighter-rouge">wasm-bingen</code>’s usefulness doesn’t stop there, however.  It also offers numerous sub-crates, such as <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys" target="_blank">js-sys</a>, which provides raw bindings to global JavaScript APIs like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare" target="_blank">String.localeCompare</a>, and <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys" target="_blank">web-sys</a>, which provides raw bindings to Web APIs like <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement" target="_blank">HTMLDivElement</a>.  These crates <a href="https://github.com/rustwasm/team/issues/226#issuecomment-417802883" target="_blank">are designed to be the libc of the web</a>, which is one of many reasons I’m excited for Rust’s potential in the WebAssembly scene.</p>

<h2 id="time-to-oxidize">Time to oxidize</h2>

<p>Okay, we have our project set up and know a little more about how our Rust ends up as usable WebAssembly modules. Let’s begin implementing the Rust version of our sorting algorithm. Fortunately, Rust has a solid date/time library called <a href="https://github.com/chronotope/chrono" target="_blank">chrono</a> that will allow us to compare dates, so this task becomes very easy.</p>

<p>In our <code class="language-plaintext highlighter-rouge">Cargo.toml</code> file, in which we specify our dependencies (among other things), let’s add our <code class="language-plaintext highlighter-rouge">chrono</code> dependency.  After doing so, <code class="language-plaintext highlighter-rouge">Cargo.toml</code> should look something like this:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"wasm"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Tyler Wilcock &lt;twilcock@widen.com&gt;"</span><span class="p">]</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2018"</span>

<span class="nn">[lib]</span>
<span class="py">crate-type</span> <span class="p">=</span> <span class="nn">["cdylib"]</span>

<span class="nn">[features]</span>
<span class="py">default-features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"console_error_panic_hook"</span><span class="p">,</span> <span class="s">"wee_alloc"</span><span class="p">]</span>

<span class="nn">[dependencies]</span>
<span class="py">cfg-if</span> <span class="p">=</span> <span class="s">"0.1.6"</span>
<span class="py">wasm-bindgen</span> <span class="p">=</span> <span class="s">"0.2"</span>
<span class="py">chrono</span> <span class="p">=</span> <span class="s">"0.4"</span>

<span class="c"># The `console_error_panic_hook` crate provides better debugging</span>
<span class="c"># of panics by logging them with `console.error`. This is great</span>
<span class="c"># for development, but requires all the `std::fmt` and</span>
<span class="c"># `std::panicking` infrastructure, so isn't great for code size</span>
<span class="c"># when deploying.</span>
<span class="nn">console_error_panic_hook</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.5"</span><span class="p">,</span> <span class="py">optional</span> <span class="p">=</span> <span class="kc">true</span> <span class="p">}</span>

<span class="c"># `wee_alloc` is a tiny allocator for wasm that is only ~1K in</span>
<span class="c"># code size compared to the default allocator's ~10K. It is</span>
<span class="c"># slower than the default allocator, however.</span>
<span class="nn">wee_alloc</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.4.2"</span><span class="p">,</span> <span class="py">optional</span> <span class="p">=</span> <span class="kc">true</span> <span class="p">}</span>
</code></pre></div></div>

<p>And now in <code class="language-plaintext highlighter-rouge">src/lib.rs</code> we will add the following code to compare our date strings:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">chrono</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">wasm_bindgen</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="nd">#[wasm_bindgen(js_name</span> <span class="nd">=</span> <span class="s">"compareDates"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">compare_dates</span><span class="p">(</span><span class="n">in_date_a</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">in_date_b</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i8</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">date_a</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">in_date_a</span><span class="p">)</span>
        <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">DateTime</span><span class="o">&lt;</span><span class="n">Utc</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"couldn't parse date_a - {}"</span><span class="p">,</span> <span class="n">in_date_a</span><span class="p">))</span>
        <span class="nf">.date</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">date_b</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">in_date_b</span><span class="p">)</span>
        <span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">DateTime</span><span class="o">&lt;</span><span class="n">Utc</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"couldn't parse date_b - {}"</span><span class="p">,</span> <span class="n">in_date_b</span><span class="p">))</span>
        <span class="nf">.date</span><span class="p">();</span>

    <span class="k">match</span> <span class="n">date_a</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">date_b</span><span class="p">)</span> <span class="p">{</span>
        <span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Voila!  We have created a function that will take two JavaScript strings, parse them as UTC dates with <code class="language-plaintext highlighter-rouge">chrono</code>, and then compare them.  We add the <code class="language-plaintext highlighter-rouge">wasm_bindgen</code> annotation so that it knows we want to make this function accessible to JavaScript under the name <code class="language-plaintext highlighter-rouge">compareDates</code>.</p>

<p>Let’s package up the code into a WebAssembly module so that JavaScript can get at it.  This is as easy as running <code class="language-plaintext highlighter-rouge">wasm-pack build</code>, which, by default, builds our code with optimizations enabled.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ wasm-pack build        

  [1/9] 🦀  Checking `rustc` version...
  [2/9] 🔧  Checking crate configuration...
  [3/9] 🎯  Adding WASM target...
  info: component 'rust-std' for target 'wasm32-unknown-unknown' is up to date
  [4/9] 🌀  Compiling to WASM...
      Finished release [optimized] target(s) in 0.49s
  [5/9] 📂  Creating a pkg directory...
  [6/9] 📝  Writing a package.json...
  ℹ️   [INFO]: Optional fields missing from Cargo.toml: 'description', 'repository', and 'license'. These are not necessary, but recommended
  [7/9] 👯  Copying over your README...
  ⚠️   [WARN]: origin crate has no README
  wasm-bindgen 0.2.21
  [8/9] ⬇️  wasm-bindgen already installed...
  [9/9] 🏃‍♀️  Running WASM-bindgen...
  ✨   Done in 0 seconds
  📦   Your wasm pkg is ready to publish at "/Users/twilcock/projects/inventory-project/frontend/rust/pkg".
</code></pre></div></div>

<p>As you might see from the output above, we have a new directory in our <code class="language-plaintext highlighter-rouge">rust/</code> directory called <code class="language-plaintext highlighter-rouge">pkg/</code>, which contains both our WebAssembly module and the JavaScript glue required to use it.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>└── frontend/
    ├── ...
    └── rust/
        ├── Cargo.toml
        └── pkg
        |   ├── package.json
        |   ├── wasm.d.ts
        |   ├── wasm.js
        |   └── wasm_bg.wasm
        |   
        └── src/
        |   ├── lib.rs
        |   └── utils.rs
        |
        └── tests/
            └── web.rs
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">.wasm</code> file isn’t going to be very interesting. Remember, WebAssembly is a binary format.  Let’s look instead look at the glue <code class="language-plaintext highlighter-rouge">wasm-bindgen</code> created for us in <code class="language-plaintext highlighter-rouge">wasm.js</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* tslint:disable */</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">wasm</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./wasm_bg</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">cachedEncoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextEncoder</span><span class="p">(</span><span class="dl">'</span><span class="s1">utf-8</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">let</span> <span class="nx">cachegetUint8Memory</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">getUint8Memory</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cachegetUint8Memory</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">cachegetUint8Memory</span><span class="p">.</span><span class="nx">buffer</span> <span class="o">!==</span> <span class="nx">wasm</span><span class="p">.</span><span class="nx">memory</span><span class="p">.</span><span class="nx">buffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cachegetUint8Memory</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">wasm</span><span class="p">.</span><span class="nx">memory</span><span class="p">.</span><span class="nx">buffer</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cachegetUint8Memory</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">passStringToWasm</span><span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buf</span> <span class="o">=</span> <span class="nx">cachedEncoder</span><span class="p">.</span><span class="nx">encode</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">ptr</span> <span class="o">=</span> <span class="nx">wasm</span><span class="p">.</span><span class="nx">__wbindgen_malloc</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
    <span class="nx">getUint8Memory</span><span class="p">().</span><span class="kd">set</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">length</span><span class="p">];</span>
<span class="p">}</span>
<span class="cm">/**
* @param {string} arg0
* @param {string} arg1
* @returns {number}
*/</span>
<span class="k">export</span> <span class="kd">function</span> <span class="nx">compareDates</span><span class="p">(</span><span class="nx">arg0</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">ptr0</span><span class="p">,</span> <span class="nx">len0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">passStringToWasm</span><span class="p">(</span><span class="nx">arg0</span><span class="p">);</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">ptr1</span><span class="p">,</span> <span class="nx">len1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">passStringToWasm</span><span class="p">(</span><span class="nx">arg1</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">wasm</span><span class="p">.</span><span class="nx">compareDates</span><span class="p">(</span><span class="nx">ptr0</span><span class="p">,</span> <span class="nx">len0</span><span class="p">,</span> <span class="nx">ptr1</span><span class="p">,</span> <span class="nx">len1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">cachedDecoder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TextDecoder</span><span class="p">(</span><span class="dl">'</span><span class="s1">utf-8</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">getStringFromWasm</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">cachedDecoder</span><span class="p">.</span><span class="nx">decode</span><span class="p">(</span><span class="nx">getUint8Memory</span><span class="p">().</span><span class="nx">subarray</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">ptr</span> <span class="o">+</span> <span class="nx">len</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">__wbindgen_throw</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">getStringFromWasm</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">len</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lots going on here. Let’s start by looking at <code class="language-plaintext highlighter-rouge">compareDates</code>.  It’s pretty bare, essentially just calling into the <code class="language-plaintext highlighter-rouge">.wasm</code> version of <code class="language-plaintext highlighter-rouge">compareDates</code>.  So, why is it here, and why do we keep referring to this code as “glue”?</p>

<p>To answer this question, there’s something else we need to know about WebAssembly: <a href="https://webassembly.github.io/spec/core/syntax/types.html" target="_blank">It currently supports a very limited number of types, namely i32, i64, f32, and f64.</a>  This obviously excludes all of the rich types we see in JavaScript, such as strings and objects.  You can probably see the issue here. Our dates are represented as strings, not integers or floats, meaning we can’t pass them as is to our WebAssembly module.</p>

<p><code class="language-plaintext highlighter-rouge">wasm-bindgen</code> solves this problem by automatically creating code that takes our rich types, like the string version of our dates, and converts them into types that WebAssembly can work with.  We see this in the <code class="language-plaintext highlighter-rouge">passStringToWasm</code> function, which takes our string, turns it into bytes, and copies those bytes from JavaScript’s heap into WebAssembly’s linear memory.  The act of allocating space for and copying of the bytified version of our string is very expensive, especially when done frequently in small increments (which is, unfortunately, exactly what we’re doing).  We’ll see just how expensive this is later on.</p>

<p>Eventually this glue code will not be necessary thanks to the <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md" target="_blank">interface types proposal</a>.  Among many other things, the interface types proposal provides a standard way to create rich types, such as strings and JSON, when passed some function that can allocate memory (<code class="language-plaintext highlighter-rouge">wee_alloc</code>, anyone?).  Interface types will also <a href="https://github.com/rustwasm/wasm-bindgen#features" target="_blank">unlock faster than JavaScript DOM access</a> since WebAssembly functions are statically checked and thus do not require the runtime-type checks that JavaScript functions do.</p>

<h2 id="back-to-javascript">Back to JavaScript</h2>

<p>We have successfully created our WebAssembly module and have generated the glue code required to use it.  First, let’s import the <code class="language-plaintext highlighter-rouge">compareDates</code> WebAssembly function we created in the previous step:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">compareDates</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../../rust/pkg/wasm</span><span class="dl">'</span>
</code></pre></div></div>

<p>Thanks to <code class="language-plaintext highlighter-rouge">wasm-pack</code>, importing this function is as easy as doing so from any other module.  Now to replace our <code class="language-plaintext highlighter-rouge">Date</code> API implementation with <code class="language-plaintext highlighter-rouge">compareDates</code>:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sortInventoryRuns</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sortBy</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">inventoryRuns</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">rowA</span><span class="p">,</span> <span class="nx">rowB</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">accountNameA</span> <span class="o">=</span> <span class="p">...</span>
    <span class="kd">const</span> <span class="nx">accountNameB</span> <span class="o">=</span> <span class="p">...</span>

    <span class="k">switch</span> <span class="p">(</span><span class="nx">sortBy</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">other</span> <span class="k">case</span> <span class="nx">statements</span><span class="p">...</span>

      <span class="k">case</span> <span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="na">wasSuccessful</span><span class="p">:</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">wasSuccessfulComparison</span> <span class="o">=</span> <span class="nx">cmp</span><span class="p">(</span><span class="nx">rowA</span><span class="p">[</span><span class="nx">sortBy</span><span class="p">],</span> <span class="nx">rowB</span><span class="p">[</span><span class="nx">sortBy</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">wasSuccessfulComparison</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Our old `Date` API comparison...</span>
          <span class="c1">// const ranOnComparison = cmp(</span>
          <span class="c1">//   new Date(rowA[TABLE_FIELDS.ranOn]).getTime(),</span>
          <span class="c1">//   new Date(rowB[TABLE_FIELDS.ranOn]).getTime()</span>
          <span class="c1">// )</span>

          <span class="c1">// And our new Rust date comparison!</span>
          <span class="kd">const</span> <span class="nx">ranOnComparison</span>
            <span class="o">=</span> <span class="nx">compareDates</span><span class="p">(</span><span class="nx">rowA</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">],</span> <span class="nx">runB</span><span class="p">[</span><span class="nx">TABLE_FIELDS</span><span class="p">.</span><span class="nx">ranOn</span><span class="p">])</span>
          <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">ranOnComparison</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span>
            <span class="nx">accountNameA</span><span class="p">.</span><span class="nx">localeCompare</span><span class="p">(</span><span class="nx">accountNameB</span><span class="p">)</span> <span class="p">:</span>
            <span class="nx">ranOnComparison</span>
          <span class="k">return</span> <span class="nx">swapIfDesc</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">swapIfDesc</span><span class="p">(</span><span class="nx">wasSuccessfulComparison</span><span class="p">,</span> <span class="nx">sortDirection</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="p">...</span><span class="nx">other</span> <span class="k">case</span> <span class="nx">statements</span><span class="p">...</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And now for the benchmarks of this newly-oxidized sort implementation.  This is with the optimized version of our Rust/WebAssembly code (remember, <code class="language-plaintext highlighter-rouge">wasm-pack build</code> optimizes by default).</p>

<p><a href="/images/tale-of-performance/benchmarks/optimized-rust.png">
    <img src="/images/tale-of-performance/benchmarks/optimized-rust.png" alt="Performance baseline graph - Chrome 183.93ms, Firefox 269.8ms, Safari 166.56ms" />
</a></p>

<p>Not too bad!  Versus our initial <code class="language-plaintext highlighter-rouge">moment</code>-based implementation, in Chrome we see a <strong>78%</strong> improvement (<strong>183.93ms</strong> to <strong>39.69ms</strong>), in Firefox a <strong>90%</strong> improvement (<strong>269.80ms</strong> to <strong>24.88ms</strong>), and in Safari an <strong>83%</strong> improvement (<strong>166.56ms</strong> to <strong>27.98ms</strong>).</p>

<p>You’ll also notice that the WebAssembly version of our date comparison code is quite a bit slower than our browser-native <code class="language-plaintext highlighter-rouge">Date</code> API implementation.  Specifically, the WebAssembly version is <strong>85%</strong> slower in Chrome (<strong>5.95ms</strong> to <strong>39.69ms</strong>), <strong>72%</strong> slower in Firefox (<strong>6.96ms</strong> to <strong>24.88ms</strong>), and <strong>72%</strong> slower in Safari (<strong>7.72ms</strong> to <strong>27.98ms</strong>).</p>

<p>Because I was curious, here are the benchmarks for the <em>unoptimized</em> version of our <code class="language-plaintext highlighter-rouge">compareDates</code> function:</p>

<p><a href="/images/tale-of-performance/benchmarks/unoptimized-rust.png">
    <img src="/images/tale-of-performance/benchmarks/unoptimized-rust.png" alt="Performance baseline graph - Chrome 183.93ms, Firefox 269.8ms, Safari 166.56ms" />
</a></p>

<p>While still acceptable for development, this is <em>much</em> slower than the performance of the optimized version, but includes debug info and debug assertions.  Versus the optimized version of <code class="language-plaintext highlighter-rouge">compareDates</code>, the unoptimized version is <strong>85%</strong> slower in Chrome (<strong>39.69ms</strong> to <strong>281.01ms</strong>), <strong>83%</strong> slower in Firefox (<strong>24.88ms</strong> to <strong>146.92ms</strong>), and <strong>83%</strong> slower in Safari (<strong>27.98ms</strong> to <strong>171.83ms</strong>).</p>

<h2 id="sweet-naivete">Sweet naivete</h2>

<p>Let’s unpack these results a bit.  It’s unsurprising that the WebAssembly version is slower than a native browser API, but our results show that it’s significantly slower - 85% slower in the worst case.  Why is it so slow?</p>

<p>To answer this question, let’s revisit our discussion about the <code class="language-plaintext highlighter-rouge">wasm-bindgen</code>’s <code class="language-plaintext highlighter-rouge">passStringToWasm</code> function.  This function takes our JavaScript strings, turns them into bytes, and then copies those bytes from JavaScript’s heap into WebAssembly’s linear memory.  This operation is <em>very</em> expensive, so much so that the <a href="https://rustwasm.github.io/book/game-of-life/implementing.html#interfacing-rust-and-javascript" target="_blank">Rust and WebAssembly book has defined some guidelines that explicitly advocate for doing it as little as possible:</a></p>

<blockquote>
  <p>When designing an interface between WebAssembly and JavaScript, we want to optimize for the following properties:</p>

  <p><strong>1.</strong> Minimize copying into and out of the WebAssembly linear memory. Unnecessary copies impose unnecessary overhead.</p>

  <p><strong>2.</strong> Minimize serializing and deserializing. Similar to copies, serializing and deserializing also impose overhead, and often impose copying as well. If we can pass opaque handles to a data structure — instead of serializing it on one side, copying it into some known location in the WebAssembly linear memory, and deserializing on the other side — we can often reduce a lot of overhead. wasm_bindgen helps us define and work with opaque handles to JavaScript objects or boxed Rust structures.</p>
</blockquote>

<p>With our very naive implementation, we break rule one…<em>a lot</em>.  For each row, we copy one date string from JavaScript’s heap into WebAssembly’s linear memory space to compare it against some other date.  Fortunately, with Chrome’s profiling tool, we can see exactly just how expensive this is in practice:</p>

<p><a href="/images/tale-of-performance/pass-string-to-wasm.png">
    <img src="/images/tale-of-performance/pass-string-to-wasm.png" alt="Image showing cost of passStringToWasm - 50% of compareDates cost" />
</a></p>

<p>As you can see, the time it takes to run <code class="language-plaintext highlighter-rouge">passStringToWasm</code> is roughly the same amount of time it takes to actually run our <code class="language-plaintext highlighter-rouge">compareDates</code> function, meaning we spend half of our execution time simply shepherding data into the right place and format.  While this naive WebAssembly implementation is still quite fast in the grand scheme of things, there is clearly some room for improvement here.</p>

<h2 id="the-right-way">The right way</h2>

<p>So, you might be wondering - if we’re doing things the wrong way, how might we do better?  Once again, the <a href="https://rustwasm.github.io/book/game-of-life/implementing.html#interfacing-rust-and-javascript" target="_blank">Rust and WebAssembly book has answers (quoted text is just under the numbered list):</a></p>

<blockquote>
  <p>As a general rule of thumb, a good JavaScript↔WebAssembly interface design is often one where large, long-lived data structures are implemented as Rust types that live in the WebAssembly linear memory, and are exposed to JavaScript as opaque handles. JavaScript calls exported WebAssembly functions that take these opaque handles, transform their data, perform heavy computations, query the data, and ultimately return a small, copy-able result. By only returning the small result of the computation, we avoid copying and/or serializing everything back and forth between the JavaScript garbage-collected heap and the WebAssembly linear memory.</p>
</blockquote>

<p>In our current implementation, all of our data lives within JavaScript’s heap, which is currently inaccessible from WebAssembly’s linear memory space (this, too, will be fixed upon implementation of the interface types proposal).  As suggested in the quote, a better implementation would instead have our table data and the entirety of our sorting logic reside inside WebAssembly.  Rather than hitting an endpoint for the table data from JavaScript, we would do so from Rust, perhaps via some exposed-to-Javascript handle.  This precludes the need for any copying, since all of our data now lives and is manipulated entirely within WebAssembly’s memory space.</p>

<p>Without the need to copy, things should be much faster.  Problem solved, right?  Well, not exactly. We still need all the table data on JavaScript’s end to actually <em>display</em> it, don’t we?  Well, fortunately for us, while WebAssembly cannot currently access JavaScript’s heap, JavaScript <em>can</em> access WebAssembly’s linear memory space via the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory" target="_blank">WebAssembly.Memory API</a>.  In even better news, <code class="language-plaintext highlighter-rouge">wasm-bindgen</code> exports the memory of our WebAssembly instance as a standard module, meaning we can <code class="language-plaintext highlighter-rouge">import</code> just as easily as we can anything else.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// From JavaScript, we can easily import WebAssembly's memory.</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">memory</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../../rust/pkg/wasm_bg</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>With this handle, we can then cheaply access our table data via <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory/buffer" target="_blank">memory.buffer</a>.  The Rust and WebAssembly book <a href="https://rustwasm.github.io/book/game-of-life/implementing.html#rendering-to-canvas-directly-from-memory" target="_blank">provides an example of this</a> in their implementation of <a href="https://bitstorm.org/gameoflife/" target="_blank">John Conway’s Game of Life</a>.  To save you from scrolling, here’s the code snippet in which they do this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Import the WebAssembly memory at the top of the file.</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">memory</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">wasm-game-of-life/wasm_game_of_life_bg</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">getIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">column</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">row</span> <span class="o">*</span> <span class="nx">width</span> <span class="o">+</span> <span class="nx">column</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">drawCells</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">cellsPtr</span> <span class="o">=</span> <span class="nx">universe</span><span class="p">.</span><span class="nx">cells</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">cells</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span>
    <span class="nx">memory</span><span class="p">.</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">cellsPtr</span><span class="p">,</span> <span class="nx">width</span> <span class="o">*</span> <span class="nx">height</span>
  <span class="p">);</span>

  <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="nx">height</span><span class="p">;</span> <span class="nx">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="nx">width</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">idx</span> <span class="o">=</span> <span class="nx">getIndex</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">);</span>

      <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="nx">cells</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="o">===</span> <span class="nx">Cell</span><span class="p">.</span><span class="nx">Dead</span>
        <span class="p">?</span> <span class="nx">DEAD_COLOR</span>
        <span class="p">:</span> <span class="nx">ALIVE_COLOR</span><span class="p">;</span>

      <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span>
        <span class="nx">col</span> <span class="o">*</span> <span class="p">(</span><span class="nx">CELL_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">row</span> <span class="o">*</span> <span class="p">(</span><span class="nx">CELL_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">CELL_SIZE</span><span class="p">,</span>
        <span class="nx">CELL_SIZE</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">ctx</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p>While switching to this paradigm would bring about performance gains versus our current WebAssembly implementation, doing so would require a fairly significant restructuring of our app, and we have already solved our immediate performance problem in a much simpler way via the native <code class="language-plaintext highlighter-rouge">Date</code> API.  This blog post is also probably long enough as is…</p>

<h2 id="random-ending-thoughts">Random ending thoughts</h2>

<p>We covered a lot throughout this post, from native JavaScript <code class="language-plaintext highlighter-rouge">Date</code>s and standard date formats all the way to the nitty gritty details of implementing a portion of our sorting algorithm in Rust and WebAssembly.  In its current state, WebAssembly is a very powerful tool; we achieved a significant speedup with an extremely naive replacement of our date comparison code.  However, as we touched on throughout the post, WebAssembly is nowhere near complete.  There <a href="https://github.com/WebAssembly/proposals" target="_blank">are a multitude of in-progress proposals</a> that will unlock vastly more performant and ergonomic workflows.</p>

<p>Thanks for reading!  If you have any questions or comments, feel free to leave them below.  Also, if you want the chance to work with some cool people and some cool technology, <a href="https://www.widen.com/careers" target="_blank">come join us!</a></p>


    </article>

    
      
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">
	    var disqus_shortname = 'widen-engineering';
	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();
	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>


    
</div>


      </main>

    </div>

    <div class="full-width">
      <div class="wrapper">
    <footer class="site-footer" role="contentinfo">
        <nav>
          <ul class="inline">
          
            
          
            
          
            
          
            
            <li>
                <a href="/open-source">Open Source Guidelines</a>
            </li>
            
          
            
          
            
          
            
          
          </ul>
          <br/>
        </nav >
        <nav aria-label="Social media links">
          <ul class="site-social-links inline">
              <li><a target="_blank" title="RSS Feed" href="/feed.xml"><ion-icon name="logo-rss"></ion-icon></a></li>
              <li><a target="_blank" title="GitHub" href="https://github.com/widen"><ion-icon name="logo-github"></ion-icon></a></li>
              <li><a target="_blank" title="Twitter" href="https://twitter.com/widendev"><ion-icon name="logo-twitter"></ion-icon></a></li>
          </ul>
        </nav>
        <p>© Copyright 2021, <a title="Widen Homepage" target="_blank" href="http://widen.com">Widen Enterprises, Inc.</a></p>
        <p><strong>Looking for work?</strong> <a title="Come engineer with us!" target="_blank" href="http://www.widen.com/careers/">Come engineer with us!</a></p>
        
<p><strong>Something wrong with this page?</strong> Please <a title="Create new issue on bugtracker" target="_blank" href="https://github.com/widen/widen.github.io/issues/new">file a bug</a>.</p>
<div class="git-info">
<nav aria-label="Site source and page information">
  <ul class="inline">
    <li>
        <a target="_blank" title="View site source on GitHub" href="https://github.com/widen/widen.github.io">source</a>
    </li>
    <li>
        <a target="_blank" title="View current page on GitHub" href="https://github.com/widen/widen.github.io/blob/master/_posts/2019-01-14-A-Tale-of-Performance---Javascript,-Rust,-and-WebAssembly.md">view</a>
    </li>
    <li>
        <a target="_blank" title="Edit current page on GitHub" href="https://github.com/widen/widen.github.io/edit/master/_posts/2019-01-14-A-Tale-of-Performance---Javascript,-Rust,-and-WebAssembly.md">edit</a>
    </li>
    <li>
        <a target="_blank" title="Last site commit" href="https://github.com/widen/widen.github.io/commit/"></a>
    </li>
    <li>
        <a target="_blank" title="Last page commit" href="https://github.com/widen/widen.github.io/commit/"></a>
    </li>
  </ul>
  </nav >
</div>


    </footer>
</div>

    </div>

    
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1206716-19']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


    <script src="https://unpkg.com/ionicons@5.1.2/dist/ionicons.js"></script>


  </body>

</html>
